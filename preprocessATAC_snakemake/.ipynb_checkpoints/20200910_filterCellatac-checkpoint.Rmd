---
title: "Explore cellatac peaks"
output: html_notebook
---

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(Seurat)
library(Signac)
library(GenomicRanges)
# BiocManager::install('EnsDb.Hsapiens.v86')
library(EnsDb.Hsapiens.v86)
library(ggbio)
library(patchwork)
library(cowplot)
## Setup to use python (for anndata conversion with sceasy)
reticulate::use_condaenv("emma_env", required = TRUE)
```


```{r, message=FALSE, warning=FALSE}
library(sceasy)

library(cellatacUtils)
# source("/nfs/team205/ed6/thATAC/preprocess_utils/cellatac_utils.R")

## Some plotting utils

theme_set(theme_grey(base_size=16))

merge_fragments <- function(bed_list, gr){
  reads_ls <- lapply(bed_list, function(x) rtracklayer::import(x, format = "bed", which = gr))
  for (i in 1:length(reads_ls)) {
    reads_ls[[i]]$sample_id <- names(reads_ls)[i]
  }
  reads_all <- unlist(as(reads_ls, "GRangesList"))
  return(reads_all)
}

plot_total_reads <- function(reads_df, smoothing_window=100){
  if (!'group_col' %in% colnames(reads_df)){
    stop("No group_col column in data.frame")
  }
  # Expand reads so have one line per base
  expanded_ranges = dplyr::bind_rows(lapply(1:nrow(reads_df), function(i) {
    interval = reads_df[i, 'start']:reads_df[i, 'stop']
    return(data.frame(position=interval,
                      value=1,
                      cell=reads_df[i, 'cell'],
                      group=reads_df[i, 'group_col']
                      ))
  }))  

  # Apply scaling factor and account for different cell counts
  # Also apply windowed smoothing

  expanded_ranges = expanded_ranges %>%
    group_by(group, position) %>%
    summarize(total=sum(value)) %>%
    ungroup() %>%
    group_by(group) %>%
    arrange(position) %>%
    mutate(total_smoothed=zoo::rollapply(total, smoothing_window, mean, align='center',fill=NA)) %>%
    ungroup()
  
  pl <- expanded_ranges %>% 
    ggplot(aes(position, total, color=group)) + geom_point(size=0.1) 
  return(pl)
}


plot_peak_gene_track <- function(peaks,  upstream = 200, downstream = 200){
  if(is.character(peaks)){
    gr_peaks <- StringToGRanges(peaks, sep = c(":","-"))
  } else {
    gr_peaks <- peaks
  }
  gr <- Extend(gr_peaks, upstream=upstream, downstream=downstream)
  start <- gr@ranges@start
  end <- gr@ranges@start + gr@ranges@width
  
  peak_track <- autoplot(gr_peaks)
  peaks_plot <- peak_track@ggplot +
    theme_nothing() +
    xlim(start, end) 
    # theme(axis.line = element_blank())
  # Add gene track using ensembl ID
  gr <- GRanges(seqnames = str_replace(gr@seqnames, 'chr', ''), IRanges(start, end), strand = "*")
  filters = AnnotationFilterList(GRangesFilter(gr), GenebiotypeFilter('protein_coding'))
  
  genes = autoplot(EnsDb.Hsapiens.v86, filters, names.expr = "gene_name")
  genes_plot = genes@ggplot +
      xlim(start, end) +
      theme_classic() 
  peaks_plot / genes_plot +
    plot_layout(heights = c(1,2))
  }
```

```{r}
cellatac_dir <- '/nfs/team205/ed6/cellatac_results/results_500k_optimized/'
win_seu <- load_cellatac_seurat(cellatac_dir)
```

## Peaks stats and QC

Main points:

1. **Normalizing peak width**:
  - Wide peaks coming from the masterlist merging
  - Schep et al. 2017 resize peaks to be 500 bps wide and centered at the summit
  - Normalizing simply dividing by width might mess up the binary matrix 
2. **Independence on cluster size:** stats such as number of called peaks and fraction of peaks in promoters etc should be independent of cluster size
3. **Peaks in small clusters should be accessible in a significant fraction of cells in the cluster** otherwise you end up having peaks that are just a few reads and noisy. Cusanovich et al. 2018 select peaks that are accessible in at least 5% of cells in a cluster identified with the windows

<!-- 4. **Dynamic range of total accessibility:** the point of calling peaks per cluster is to identify peaks that are not extremely highly accessible in the aggregated profiles   -->


### Load peaks as GenomicRanges 

Merge peaks in a single bed file (without merging overlapping peaks). In terminal:
```
### All peaks without merging
cd $cellatac_dir
np_files=macs2/*_peaks.narrowPeak 
cat ${np_files} | cut -f 1-4 | sort -k1,1 -k2,2n > allclusters_peaks_sorted.bed

### Merged masterlist counting overlaps
cat allclusters_peaks_sorted.bed  | sed 's/_peak_.*//g' > allclusters_peaks_sorted_cl.bed
bedtools merge -i allclusters_peaks_sorted_cl.bed -d -1 -c 4 -o count_distinct > allclusters_masterlist.bed
```

```{r}
## 1. All peaks
allpeaks <- rtracklayer::import("/nfs/team205/ed6/cellatac_results/results_500k_optimized/allclusters_peaks_sorted_cl.bed")
allpeaks <- annotate_gr(allpeaks)
colnames(allpeaks@elementMetadata)[1] <- "cluster"

## 2. Peak masterlist
peaks_gr <- rtracklayer::import("/nfs/team205/ed6/cellatac_results/results_500k_optimized/allclusters_masterlist.bed", format="bed")
peaks_gr <- Extend(peaks_gr, upstream = 1) ## To match ids in Seurat object
colnames(peaks_gr@elementMetadata)[1] <- "count_distinct"
peaks_gr <- annotate_gr(peaks_gr)

peaks_tab <- data.frame(peaks_gr@elementMetadata) %>%
  mutate(peak_id=GRangesToString(peaks_gr, sep=c(":", "-")))
```

### Calculate peak QC metrics

`compute_peakQC` stores information in `assay@meta.features`

```{r, message=FALSE, warning=FALSE}
win_seu <- compute_peakQC(win_seu, cluster_col = "seurat_clusters")
```

```{r}
win_seu@assays$peaks@meta.features
```


### 1. Peak width / coverage dependency

#### Distribution of peak width across clusters

Width in masterlist comes from merging of multiple peaks

```{r, fig.width=10, fig.height=5}
w_hist_all <- allpeaks@elementMetadata %>%
  data.frame() %>%
  ggplot(aes(peak_width)) + geom_histogram(bins=100)

w_hist_master <- peaks_tab %>%
  ggplot(aes(peak_width)) + geom_histogram(bins=100)

(w_hist_all + ggtitle("all peaks")) | (w_hist_master + ggtitle("masterlist peaks"))
```

Peaks detected in more clusters are wider. Peaks found in a single cluster are skewed towards the peak width threshold coded in MACS2, probably noise.

```{r, fig.height=4, fig.width=10, message=FALSE, warning=FALSE}
peaks_stats <- win_seu@assays$peaks@meta.features %>%
  rownames_to_column("peak_id") %>%
  left_join(dplyr::select(peaks_tab, peak_id, count_distinct)) %>%
  mutate(count_distinct=as.numeric(count_distinct)) 

peaks_stats %>%
  ggplot(aes(peak_width, color=count_distinct, group=count_distinct)) +
  geom_density(alpha=0.6) +
  scale_color_viridis_c(name="# clusters") 
```

```{r, fig.width=10, fig.height=4}
## Order clusters by size
cl_size <- table(win_seu$seurat_clusters)

allpeaks@elementMetadata %>%
  data.frame() %>%
  mutate(cluster_size = cl_size[cluster]) %>%
  ggplot(aes(peak_width, color=cluster_size, group=cluster)) +
  geom_density(alpha=0.6) +
  scale_color_viridis_c() 
  
```


```{r}
peaks_stats %>% 
  ggplot(aes(peak_width,tot_cells)) +
  geom_point(size=0.1, alpha=0.4) +
  theme_grey(base_size=18) +
  ggpubr::stat_cor()
```

### 2. Stats are independent of cluster size

Few outliers, cl 21 and cl 27

```{r, fig.width=14, fig.height=7}
cl_umap <- DimPlot(win_seu, reduction="umap_win", group.by = "seurat_clusters", label=TRUE) + NoLegend() +
  coord_fixed()

anno_df <- allpeaks@elementMetadata %>%
  data.frame() %>%
  mutate(cluster_size = cl_size[cluster]) %>%
  arrange(cluster_size) %>%
  mutate(cluster=factor(cluster, levels=unique(cluster)))

bp1 <- anno_df %>%
  ggplot(aes(cluster)) +
  geom_bar() +
  theme(axis.title.x = element_blank())

bp2 <- anno_df %>%
  ggplot(aes(cluster, fill=annotation)) +
  geom_bar(position="fill") +
  ylab("fraction")

(cl_umap | (bp1 / bp2)) + plot_layout(widths=c(1,2))
```

Percentage of peaks in blacklist

```{r}
anno_df %>%
  group_by(cluster) %>%
  summarise(n_cluster=n(), n_blacklist=sum(ENCODE_blacklist)) %>%
  ggplot(aes(cluster, n_blacklist/n_cluster)) +
  geom_col() +
  ylab("fraction in blacklist")
```

### 3. Peak height normalized per cluster size

Visualize some short peaks (close to threshold length for peak calling). Most appear to be accessible only in a small percentage of cells from any given cluster.

```{r, message=FALSE, warning=FALSE, echo=TRUE}

pl_peak_w_clusters <- function(reads_df, smoothing_window=100){
  
  reads_df <- reads_df %>%
    left_join(clus_df, by="cell") %>%
    drop_na() %>%
    as.data.frame()

  # Expand reads so have one line per base
  expanded_ranges = dplyr::bind_rows(lapply(1:nrow(reads_df), function(i) {
      interval = reads_df[i,"start", drop=TRUE]:reads_df[i,"stop", drop=TRUE]
      return(data.frame(position=interval,
                        value=1,
                        cell=reads_df[i, 'cell'],
                        group=reads_df[i, 'group_col'],
                        cluster=reads_df[i,"seurat_clusters"],
                        # scaling_factor=reads[i, 'total_reads'] ,
                        cells_in_group=reads_df[i, 'cells_in_group']
                        ))
    }))  
  
    # Apply scaling factor and account for different cell counts
    # Also apply windowed smoothing
    expanded_ranges = expanded_ranges %>%
      group_by(position, cluster) %>%
      summarize(total=sum(value),
                norm_total=sum(value) / mean(cells_in_group)) %>%
      ungroup() %>%
      group_by(cluster) %>%
      arrange(position) %>%
      mutate(total_smoothed=zoo::rollapply(total, smoothing_window, mean, align='center',fill=NA)) %>%
      ungroup()
    pl <- expanded_ranges %>% 
      ggplot(aes(position, norm_total, fill=cluster)) + 
      geom_area() +
      facet_grid(cluster~.)
    #   return(pl)
  return(pl)  
}

pl_narrow_peaks <- function(peaks){
  peak <- GRangesToString(peaks)
  gr_peaks <- StringToGRanges(peak, sep = c(":","-"))
  gr <- Extend(gr_peaks, upstream = 200, downstream = 200)
  
  reads <- merge_fragments(bed_list, gr=gr)
  reads_df <- data.frame(reads)[, c(1:3, 6,8)]
  colnames(reads_df) = c('chrom', 'start', 'stop', 'cell', 'group_col')
  
  pl <- pl_peak_w_clusters(reads_df, smoothing_window = 1)
  pl <- pl + xlim(gr@ranges@start, gr@ranges@start + gr@ranges@width)
  
    start <- gr@ranges@start
    end <- gr@ranges@start + gr@ranges@width
  
  peak_track <- autoplot(gr_peaks)
  peaks_plot <- peak_track@ggplot +
    theme_nothing() +
    xlim(start, end) +
    theme(axis.line = element_blank())

peaks_plot / pl + plot_layout(heights = c(1,15))
}

```

```{r, fig.width=10, fig.height=15, echo=TRUE, message=FALSE, warning=FALSE}
clus_df <- win_seu@meta.data %>% 
  rownames_to_column("cell") %>%
  dplyr::select(cell, seurat_clusters) %>%
  mutate(cell=(str_remove(cell, "^.-"))) %>%
  group_by(seurat_clusters) %>%
  mutate(cells_in_group = n()) %>%
  ungroup()

bed_list <- list.files("/nfs/team205/ed6/thymus_data/", pattern = "fragments.tsv.gz$", full.names = TRUE)
bed_list <- as.list(bed_list) %>% setNames(c("F74", "F75", "F76"))

narrow_peaks <- allpeaks[which(allpeaks$peak_width==200)]
peaks <- sample(narrow_peaks,10)

lapply(1:length(peaks), function(x) pl_narrow_peaks(peaks[x]))

```

A large number of features is never accessible in more than 10% of cells of any given cluster.

```{r}
peaks_stats %>%
  ggplot(aes(max_frac)) +
  stat_ecdf() +
  geom_vline(xintercept = 0.10, color="red")
```

```{r}
peaks_stats %>% 
  ggplot(aes(max_frac, peak_width)) +
  geom_point(size=0.1, alpha=0.4) 
```

```{r}
peaks_stats %>%
  ggplot(aes(tss_distance)) + 
  geom_histogram(bins=100) +
  facet_wrap(annotation~., scales="free")
```


### Filter peaks 

Subsetting to peaks that are not just noise in small clusters

```{r}
sel_peaks <- dplyr::filter(peaks_stats, max_frac > 0.1 & tot_count < 10000 & ENCODE_blacklist == 0) %>%
  pull(peak_id)

thatac_seu <- win_seu[sel_peaks,]
thatac_seu
```


### Filter cells

Cell stats on peak matrix

```{r, fig.width=10, fig.height=4}
data.frame(tot_peaks = thatac_seu$nFeature_peaks, tot_win = thatac_seu$nFeature_win) %>%
  # dplyr::filter(tot_peaks < 00)
  ggplot(aes(tot_peaks)) + 
  # stat_ecdf() +
  geom_histogram(bins=1000) +
  geom_vline(xintercept = 200, color="red") 
```

```{r}
thatac_seu <- subset(thatac_seu, cells=names(which((win_seu$nCount_peaks < 20000) & (win_seu$nCount_peaks > 200))))
```

Then filter by fraction of fragments in TSS (cells don't cluster well in UMAP if you don't clean this)

```{r}
data.frame(TSS_fragments = thatac_seu$TSS_fragments, tot_win = thatac_seu$nFeature_win)  %>%
    ggplot(aes(TSS_fragments)) + 
  # stat_ecdf() +
  geom_histogram(bins=500) +
  geom_vline(xintercept = 500, color="red") 
```
```{r}
thatac_seu <- subset(thatac_seu, cells=names(which((win_seu$TSS_fragments > 500))))
```

```{r}
thatac_seu
```


<!-- ### Dimensionality reduction on peak matrix -->

<!-- Using LSI method just as clustering on windows -->

<!-- ```{r} -->
<!-- DefaultAssay(thatac_seu) <- "peaks" -->

<!-- thatac_seu <- BinarizeCounts(thatac_seu, assay = "peaks") -->
<!-- thatac_seu <- RunTFIDF(thatac_seu, method=1) -->
<!-- thatac_seu <- FindTopFeatures(thatac_seu, min.cutoff = 'q0') -->
<!-- thatac_seu <- RunSVD(thatac_seu,  assay = 'peaks', reduction.key = 'LSIpeaks_', reduction.name = 'lsi_peaks') -->
<!-- ``` -->

<!-- Is first PC related to total coverage?  -->

<!-- ```{r} -->
<!-- FeatureScatter(thatac_seu, "LSIpeaks_1", "nFeature_peaks", group.by = "sample_id") -->
<!-- ``` -->

<!-- ### Embedding -->
<!-- ```{r} -->
<!-- thatac_seu <- RunUMAP(thatac_seu, reduction = "lsi_peaks", dims = 2:30, reduction.name = "umap_peaks") ## Exclude first PC as suggested by Signac, Cusanovich etc -->
<!-- ``` -->

<!-- ```{r, fig.width=6, fig.height=6} -->
<!-- DimPlot(thatac_seu, reduction="umap_peaks", label=TRUE) + NoLegend()  -->
<!-- DimPlot(thatac_seu, reduction="umap_peaks", group.by = "sample_id", label=TRUE) + NoLegend()  -->
<!-- DimPlot(thatac_seu, reduction="umap_win", group.by = "sample_id", label=TRUE) + NoLegend() + ggtitle("windows x cells") -->
<!-- ``` -->

## Where are the retained peaks? Visualize peaks close to genes

```{r}
## Because Seurat is broken
pl_peak <- function(peak){
  peak_df <- thatac_seu@assays$peaks[peak,] %>%
    as.matrix() %>%
    t() %>%
    reshape2::melt(varnames=c('cell','feature'))
  
  pl <- Embeddings(thatac_seu, reduction = "umap_peaks") %>%
    data.frame() %>%
    rownames_to_column('cell') %>%
    left_join(peak_df) %>%
    dplyr::filter(feature==peak) %>%
    arrange(value) %>%
    # mutate(feature = win_sel@assays$peaks@counts)
    ggplot(aes(UMAP_1, UMAP_2, color=value)) +
    geom_point(size=0.1) +
    scale_color_gradient(high="red", low="grey100") +
    facet_wrap(feature ~.)
  return(pl)
}

sel_peaks_gr <- StringToGRanges(rownames(thatac_seu), sep=c(":","-"))
sel_peaks_gr$gene_name <- thatac_seu@assays$peaks@meta.features$gene_name
```

#### CD8

```{r, fig.width=7, fig.height=3, message=FALSE, warning=FALSE}
cd8a_peaks <- sel_peaks_gr[which(sel_peaks_gr$gene_name=="CD8A")]
plot_peak_gene_track(cd8a_peaks)
```

#### CD4
```{r, fig.width=7, fig.height=3, message=FALSE, warning=FALSE}
cd4_peaks <- sel_peaks_gr[which(sel_peaks_gr$gene_name=="CD4")]

plot_peak_gene_track(cd4_peaks)
```


<!-- ```{r, fig.height=5, fig.width=10, message=FALSE, warning=FALSE} -->
<!-- peaks <- GRangesToString(cd4_peaks[c(1,2)], sep = c(":","-")) -->
<!-- plots <- lapply(peaks, function(x) pl_peak(x)) -->
<!-- plots -->
<!-- ``` -->

#### Recombinase (RAG1 RAG2)
```{r, fig.width=7, fig.height=3, message=FALSE, warning=FALSE}
rag_peaks <- sel_peaks_gr[which(sel_peaks_gr$gene_name=="RAG1")]
plot_peak_gene_track(rag_peaks)
```

<!-- ```{r, fig.height=5, fig.width=10, message=FALSE, warning=FALSE} -->
<!-- peaks <- GRangesToString(rag_peaks[c(1)], sep = c(":","-")) -->
<!-- plots <- lapply(peaks, function(x) pl_peak(x)) -->
<!-- plots -->
<!-- ``` -->

<!-- #### Early DN markers -->
<!-- ```{r, fig.width=7, fig.height=3, message=FALSE, warning=FALSE} -->
<!-- igll1_peaks <- sel_peaks_gr[which(sel_peaks_gr$gene_name=="CD27")] -->
<!-- plot_peak_gene_track(igll1_peaks) -->


<!-- ``` -->

<!-- ```{r, fig.height=5, fig.width=10, message=FALSE, warning=FALSE} -->
<!-- peaks <- GRangesToString(igll1_peaks[c(1)], sep = c(":","-")) -->
<!-- plots <- lapply(peaks, function(x) pl_peak(x)) -->
<!-- plots -->
<!-- ``` -->

### Save object as h5ad

```{r}
# saveRDS(thatac_seu, file = '/nfs/team205/ed6/data/thymus_data/thymusATAC_cellatacPeaks_20200910.Seurat.RDS')
thatac_seu <- readRDS(file = '/nfs/team205/ed6/data/thymus_data/thymusATAC_cellatacPeaks_20200910.Seurat.RDS')
```


```{r}
sceasy::convertFormat(thatac_seu, from="seurat", to="anndata", assay="peaks", main_layer = "counts",
                       outFile='/nfs/team205/ed6/data/thymus_data/thymusATAC_cellatacPeaks_20200910.h5ad')
```


